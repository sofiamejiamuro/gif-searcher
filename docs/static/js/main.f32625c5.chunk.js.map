{"version":3,"sources":["components/AddCategory.js","components/GifGridItem.js","helpers/getGifs.js","hooks/useFetchGifs.js","components/GifGrid.js","GifExpertApp.js","index.js"],"names":["AddCategory","setCategories","useState","inputValue","setInputValue","onSubmit","e","preventDefault","trim","length","cats","type","value","onChange","target","GifGridItem","title","url","className","src","alt","getGifs","category","a","encodeURI","fetch","resp","json","data","gifs","map","gif","id","images","downsized_medium","useFetchGifs","loading","state","setState","useEffect","then","GifGrid","key","GifExpertApp","categories","ReactDOM","render","document","getElementById"],"mappings":"iMAsCeA,EAnCK,SAAC,GAAyB,IAAtBC,EAAqB,EAArBA,cAAqB,EAGLC,mBAAS,IAHJ,mBAGnCC,EAHmC,KAGvBC,EAHuB,KAoB3C,OACE,0BAAMC,SAXa,SAACC,GACpBA,EAAEC,iBAEEJ,EAAWK,OAAOC,OAAS,IAE7BR,GAAc,SAAAS,GAAI,OAAMP,GAAN,mBAAqBO,OACvCN,EAAc,OAMd,2BACEO,KAAK,OACLC,MAAQT,EACRU,SApBoB,SAACP,GAEzBF,EAAcE,EAAEQ,OAAOF,YCEZG,EAVK,SAAC,GAAoB,IAAlBC,EAAiB,EAAjBA,MAAOC,EAAU,EAAVA,IAE5B,OACE,yBAAKC,UAAU,8CACb,2BAAKF,GACL,yBAAKG,IAAMF,EAAMG,IAAMJ,M,uBCadK,EApBF,uCAAG,WAAOC,GAAP,uBAAAC,EAAA,6DAERN,EAFQ,iDAEyCO,UAAUF,GAFnD,+DAGKG,MAAMR,GAHX,cAGRS,EAHQ,gBAISA,EAAKC,OAJd,uBAINC,EAJM,EAINA,KAIFC,EAAOD,EAAKE,KAAI,SAAAC,GACpB,MAAO,CACLC,GAAID,EAAIC,GACRhB,MAAOe,EAAIf,MACXC,IAAKc,EAAIE,OAAOC,iBAAiBjB,QAZvB,kBAiBPY,GAjBO,4CAAH,sDC8BEM,EA1BM,SAAEb,GAAe,IAAD,EAEPpB,mBAAS,CACnC0B,KAAM,GACNQ,SAAS,IAJwB,mBAE3BC,EAF2B,KAEpBC,EAFoB,KAsBnC,OAbAC,qBAAU,WAERlB,EAAQC,GACLkB,MAAM,SAAAX,GAELS,EAAS,CACPV,KAAKC,EACLO,SAAS,SAGd,CAAEd,IAGEe,GC2CMI,EAhEC,SAAC,GAAkB,IAAhBnB,EAAe,EAAfA,SAAe,EAEAa,EAAab,GAAhCO,EAFmB,EAExBD,KAAYQ,EAFY,EAEZA,QAyCpB,OACE,oCACE,4BAAMd,GAEJc,GAAW,sCAEb,yBAAKlB,UAAU,aAGbW,EAAKC,KAAI,SAACC,GAAD,OACP,kBAAC,EAAD,eACEW,IAAMX,EAAIC,IACLD,UCpBFY,EApCM,WAAM,MAKazC,mBAAS,CAAC,KALvB,mBAKjB0C,EALiB,KAKL3C,EALK,KAgBzB,OACE,oCACE,4CAEA,kBAAC,EAAD,CAAaA,cAAgBA,IAC7B,6BACA,4BAEI2C,EAAWd,KAAK,SAAAR,GAAQ,OACtB,kBAAC,EAAD,CACEoB,IAAMpB,EACNA,SAAWA,U,MCxBzBuB,IAASC,OAEP,kBAAC,EAAD,MACAC,SAASC,eAAe,U","file":"static/js/main.f32625c5.chunk.js","sourcesContent":["import React, { useState } from 'react';\nimport PropTypes from 'prop-types';\n\nconst AddCategory = ( { setCategories } ) => {\n\n  // useState() si dejamos sin argumenttos el metodo es undefined, entonces inputValue es undefined\n  const [ inputValue, setInputValue ] = useState('');\n\n  const handleInputChange = (e) => {\n    // console.log(e.target.value);\n    setInputValue(e.target.value)\n  };\n\n  const hanldeSubmit = (e) => {\n    e.preventDefault();\n    //console.log('Submit hecho');\n    if( inputValue.trim().length > 1 ){\n       // Con esta callback accedemos a las cats sin necesidad de que pasen como props vs setCategories( ['Ranma 1/2',...categories] );\n      setCategories(cats => [ inputValue, ...cats ])\n      setInputValue('')\n    }\n  };\n\n  return (\n    <form onSubmit={ hanldeSubmit }>\n      <input \n        type=\"text\"\n        value={ inputValue }\n        onChange={ handleInputChange }\n      ></input>\n    </form>\n  )\n}\n\nAddCategory.propTypes = {\n  setCategories: PropTypes.func.isRequired\n}\n\nexport default AddCategory;","import React from 'react';\n\nconst GifGridItem = ({ title, url }) => {\n  \n  return (\n    <div className=\"card animate__animated animate__rubberBand\">\n      <p>{ title }</p>\n      <img src={ url } alt={ title }></img>     \n    </div>\n  )\n}\n\nexport default GifGridItem;","const getGifs = async( category ) => {\n\n  const url = `https://api.giphy.com/v1/gifs/search?q=${ encodeURI(category) }&limit=10&api_key=9LfBNSlZUPaiGzvZGZwZVIAEIoxJvANu`;\n  const resp = await fetch(url);\n  const { data } = await resp.json();\n\n  // console.log('data en fetch',data);\n  // Array de onbjetos que vamos a mapear para obtener otro array de objetos con as propiedades que necesitamos de cada uno \n  const gifs = data.map(gif => {\n    return {\n      id: gif.id,\n      title: gif.title,\n      url: gif.images.downsized_medium.url\n    }\n  })\n\n  // console.log('gifs', gifs);\n  return gifs;\n}\n\nexport default getGifs;","// Custom Hooks \nimport { useState, useEffect } from 'react';\nimport getGifs from '../helpers/getGifs';\n\nconst useFetchGifs = ( category ) => {\n  \n  const [ state, setState ] = useState({\n    data: [],\n    loading: true\n  });\n \n  //(callback , arreglo de dependencias)\n  // use effect can not be async esperan algo sincornop\n  useEffect(() => {\n    // Es una promesa\n    getGifs(category)\n      .then( gifs => {\n        // console.log('gifsenpromesa',gifs);\n        setState({\n          data:gifs,\n          loading: false\n        })\n      })\n  }, [ category ])\n\n  // console.log('dataarrdeobj',state.data);\n  return state\n\n}\n\nexport default useFetchGifs;","import React from 'react';\nimport GifGridItem from './GifGridItem';\nimport useFetchGifs from '../hooks/useFetchGifs';\n// import getGifs from '../helpers/getGifs'\n\nconst GifGrid = ({ category }) => {\n\n  const { data:gifs , loading } = useFetchGifs(category);\n  // console.log('dataengifgrid',images); // Un Arry que contiene un Array de Objetos\n\n\n  // Donde category es un item string del array, ya paso por map \n  // const [ gifs, setGifs ] = useState([])\n\n  // useState it is not convienient because each time react detects a change it will rerender so reretrieve the data, that is make the petition over and over, e.g. counter\n  // that's why we use useEffect(), that executes code conditionally \n\n  /* //(callback , arreglo de dependencias)\n  useEffect(() => {\n    // es una promesa\n    getGifs(category)\n    // gifs es un array de objetos\n    .then( gifs => setGifs(gifs))\n  }, [ category ]) */\n\n  /* \n  Two different ways to write a map, depending on the explicit or implicit return \n  {\n    images.map(img => {\n      return <li \n        key={ img.id }\n      >\n        <p>{ img.title }</p>\n        <img src={ img.url }></img>\n      </li>\n    })\n  }\n  {\n    images.map(img => (\n      <li \n        key={ img.id }\n      >\n        <p>{ img.title }</p>\n        <img src={ img.url }></img>\n      </li>\n    ))\n  } */\n\n  return (\n    <>\n      <h3>{ category }</h3>\n\n      { loading && <p>Loading</p> }\n\n      <div className=\"card-grid\">\n      {\n        // console.log('images',images) // \n        gifs.map((gif) => (\n          <GifGridItem \n            key={ gif.id }\n            { ...gif }\n          />\n        ))\n      }\n      </div>\n    </>\n  )\n}\n\nexport default GifGrid;","import React, { useState } from 'react';\nimport AddCategory from './components/AddCategory';\nimport GifGrid from './components/GifGrid'\n\nconst GifExpertApp = () => {\n\n  // const no se deben mutar, cómo react sabe que hubo un cambio y hay que renderizar otra vez?, un arr no sirve, ñor eso susamos useState\n  // const categories = ['One Punch', 'Samurai X', 'Dragon Ball'];\n\n  const [ categories, setCategories ] = useState(['']);\n  // console.log(setCategories)\n  // Warning: Each child in a list should have a unique \"key\" prop.\n  // category vs index\n\n  /* const handleAdd = () => {\n    // setCategories( [...categories, 'Ranma 1/2'] );\n    // setCategories( ['Ranma 1/2',...categories] );\n    setCategories(cats => [...cats, 'Ranma 1/2'])\n  } */\n\n  return (\n    <>\n      <h2>GifExpertApp</h2>\n      {/* Estoy pasando como prop toda la función para poder ocuparla en el componente */}\n      <AddCategory setCategories={ setCategories }/>\n      <hr />\n      <ol>\n        {\n          categories.map( category  => (\n            <GifGrid \n              key={ category }\n              category={ category }\n            />\n          ))\n        }\n      </ol>\n    </>\n  )\n}\n\nexport default GifExpertApp;","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport GifExpertApp from './GifExpertApp'\n\nimport './index.css';\n\nReactDOM.render(\n\n  <GifExpertApp />,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}